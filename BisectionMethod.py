import numpy as npimport pandas as pdimport matplotlib.pyplot as mpfrom math import sqrtimport pandas as pddef myMod(a) :    if(a<0) :        return -a    else:        return adef equilibriumEquation(x,p,k):    return  (x/(1-x))*sqrt((2*p)/(2+x)) - k ;def plottingCurve():    x_coord1 = np.arange(-1.99,0.99,0.1)    x_coord2 = np.arange(1.09,3.99,0.1)    y1 = []    y2 = []    for i in x_coord1:        y1.append(equilibriumEquation(i, 3.0, 0.05))        for i in x_coord2:        y2.append(equilibriumEquation(i, 3.0, 0.05))        y_coord1 = np.array(y1)    y_coord2 = np.array(y2)        fig , ax = mp.subplots()        ax.axhline(y=0, color = 'k')    ax.axvline(x=0, color = 'k')        mp.plot(x_coord1,y_coord1)    mp.plot(x_coord2,y_coord2)    mp.ylabel('Mole Fraction')    mp.xlabel('Equilibrium Equation')    mp.show()    def bisectionMethod(lowerBound,upperBound,apprxError,maxIteration) :    iteration = 0    calcError = 0.0    oldRoot = 0.0        while(iteration <= maxIteration) :        iteration = iteration + 1        decision = equilibriumEquation(lowerBound, 3.0, 0.05) * equilibriumEquation(upperBound, 3.0, 0.05)        if(decision > 0.0) :            print('No Roots available between the bounds.')            return (lowerBound+upperBound)/2.0                elif(decision == 0.0) :            if(equilibriumEquation(lowerBound,3.0,0.05) == 0) :                return lowerBound            else :                return upperBound                    else :            newRoot = (lowerBound+upperBound)/2.0            if(iteration != 1) :                calcError = (myMod(newRoot-oldRoot)/myMod(newRoot)) * 100                if(calcError <= apprxError) :                    return newRoot            if(equilibriumEquation(lowerBound, 3, 0.05)*equilibriumEquation(newRoot, 3, 0.05) < 0.0) :                upperBound = newRoot            elif(equilibriumEquation(lowerBound, 3, 0.05)*equilibriumEquation(newRoot, 3, 0.05) > 0.0) :                lowerBound = newRoot            else :                return newRoot            oldRoot = newRoot        return oldRootdef bisectionMethodReturningTable(lowerBound,upperBound,apprxError,maxIteration) :    iteration = 0    calcError = 0.0    oldRoot = 0.0        error = []        while(iteration <= maxIteration) :        iteration = iteration + 1        decision = equilibriumEquation(lowerBound, 3.0, 0.05) * equilibriumEquation(upperBound, 3.0, 0.05)        if(decision > 0.0) :            print('No Roots available between the bounds.')            return error                elif(decision == 0.0) :            if(equilibriumEquation(lowerBound,3.0,0.05) == 0) :                return error            else :                return error                    else :            newRoot = (lowerBound+upperBound)/2.0            if(iteration != 1) :                calcError = (myMod(newRoot-oldRoot)/myMod(newRoot)) * 100                error.append(calcError)                #if(calcError <= apprxError) :                 #   return table            if(equilibriumEquation(lowerBound, 3, 0.05)*equilibriumEquation(newRoot, 3, 0.05) < 0.0) :                upperBound = newRoot            elif(equilibriumEquation(lowerBound, 3, 0.05)*equilibriumEquation(newRoot, 3, 0.05) > 0.0) :                lowerBound = newRoot            else :                return error            oldRoot = newRoot        return errorerror = bisectionMethodReturningTable(-0.65, 0.7, 0.5,20)root = bisectionMethod(-1.0, 0.99, 0.5, 20)print("The Root is: ")print(root)dataTable = pd.DataFrame(error,columns=['Absolute Relative Approx. Error'])print(dataTable)plottingCurve()